\hypertarget{classpacketHandler}{
\section{packetHandler Class Reference}
\label{classpacketHandler}\index{packetHandler@{packetHandler}}
}


Class the serve packets to the \hyperlink{classDataPlot}{DataPlot}.  




{\ttfamily \#include $<$packethandler.h$>$}

\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classpacketHandler_ab1a61d0c1deef1885e31b9a6aebdcc2f}{
void \hyperlink{classpacketHandler_ab1a61d0c1deef1885e31b9a6aebdcc2f}{connected} ()}
\label{classpacketHandler_ab1a61d0c1deef1885e31b9a6aebdcc2f}

\begin{DoxyCompactList}\small\item\em Slot for when a connection is established. This also initializes communication with the serial forwarder. \item\end{DoxyCompactList}\item 
void \hyperlink{classpacketHandler_a43223a8930a6af8c40c5889d8e4b9d4b}{disconnected} ()
\begin{DoxyCompactList}\small\item\em Slot for when we are disconnected from the serial forwarder. \item\end{DoxyCompactList}\item 
void \hyperlink{classpacketHandler_a9085a61a51eccc7acb240a7b68601686}{dataReady} ()
\begin{DoxyCompactList}\small\item\em Slot for when there is new data ready from the serial forwarder. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Signals}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classpacketHandler_a0e8f4d081f531b5e568c052f5b8babb9}{
void \hyperlink{classpacketHandler_a0e8f4d081f531b5e568c052f5b8babb9}{nodesChanged} ()}
\label{classpacketHandler_a0e8f4d081f531b5e568c052f5b8babb9}

\begin{DoxyCompactList}\small\item\em Signal emitted when a new node is detected. \item\end{DoxyCompactList}\item 
\hypertarget{classpacketHandler_a033895b001ec68791c5d0872df03e626}{
void \hyperlink{classpacketHandler_a033895b001ec68791c5d0872df03e626}{disconnectNotice} ()}
\label{classpacketHandler_a033895b001ec68791c5d0872df03e626}

\begin{DoxyCompactList}\small\item\em Signal emitted when disconnected from the serial forwarder. \item\end{DoxyCompactList}\item 
\hypertarget{classpacketHandler_ad3e95ebbb80274b826502fb84f8f100b}{
void \hyperlink{classpacketHandler_ad3e95ebbb80274b826502fb84f8f100b}{sFconnected} ()}
\label{classpacketHandler_ad3e95ebbb80274b826502fb84f8f100b}

\begin{DoxyCompactList}\small\item\em Signal emitted when connected to the serial forwarder. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classpacketHandler_a02936b9105618ed38701274efcfa0dfb}{packetHandler} ()
\begin{DoxyCompactList}\small\item\em Default constructor. \item\end{DoxyCompactList}\item 
\hypertarget{classpacketHandler_ad3c118caa3c1f8ace95c67af0843f01b}{
\hyperlink{classpacketHandler_ad3c118caa3c1f8ace95c67af0843f01b}{$\sim$packetHandler} ()}
\label{classpacketHandler_ad3c118caa3c1f8ace95c67af0843f01b}

\begin{DoxyCompactList}\small\item\em Destructor. \item\end{DoxyCompactList}\item 
QList$<$ int $>$ \hyperlink{classpacketHandler_a7d07166d577b014234ad311599ac3291}{getNodeList} ()
\item 
\hyperlink{classMoteReading}{MoteReading} \hyperlink{classpacketHandler_aec6fa94602daa18227491b76001152cb}{getReading} (int i)
\item 
bool \hyperlink{classpacketHandler_a9366836a2e226a3193bea82dcbe80b5d}{connectToDatabase} ()
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Class the serve packets to the \hyperlink{classDataPlot}{DataPlot}. \begin{DoxyAuthor}{Author}
Jharrod LaFon 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
Spring 2010 
\end{DoxyDate}
\begin{DoxyRemark}{Remarks}
This class connects to the serial forwarder, and demultiplexes packets for the datagraph class. 
\end{DoxyRemark}


Definition at line 24 of file packethandler.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classpacketHandler_a02936b9105618ed38701274efcfa0dfb}{
\index{packetHandler@{packetHandler}!packetHandler@{packetHandler}}
\index{packetHandler@{packetHandler}!packetHandler@{packetHandler}}
\subsubsection[{packetHandler}]{\setlength{\rightskip}{0pt plus 5cm}packetHandler::packetHandler ()}}
\label{classpacketHandler_a02936b9105618ed38701274efcfa0dfb}


Default constructor. 



\begin{Desc}
\item[\hyperlink{todo__todo000005}{Todo}]Remove this line after debugging \end{Desc}


\begin{Desc}
\item[\hyperlink{todo__todo000006}{Todo}]Make this connection user configurable. \end{Desc}




Definition at line 12 of file packethandler.cpp.




\begin{DoxyCode}
13 {
14     // Initialize variables and objects
15     count = 0;
17 //    ringIndex.push_back(0);   QList<MoteReading> temp; ringBuffer.push_back(tem
      p); motes.push_back(0);
18 
19     // Initialize socket
21     source = new QTcpSocket();
22     source->connectToHost("localhost",9002,QIODevice::ReadWrite);
23 
24     // Connect to Database
25     connectToDatabase();
26 
27     // Connect signals
28     connect(source, SIGNAL(connected()), this, SLOT(connected()));
29     connect(source, SIGNAL(readyRead()),this, SLOT(dataReady()));
30     connect(source, SIGNAL(disconnected()), this, SLOT(disconnected()));
31 
32 
33 
34 }
\end{DoxyCode}




Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=298pt]{classpacketHandler_a02936b9105618ed38701274efcfa0dfb_cgraph}
\end{center}
\end{figure}




\subsection{Member Function Documentation}
\hypertarget{classpacketHandler_a9366836a2e226a3193bea82dcbe80b5d}{
\index{packetHandler@{packetHandler}!connectToDatabase@{connectToDatabase}}
\index{connectToDatabase@{connectToDatabase}!packetHandler@{packetHandler}}
\subsubsection[{connectToDatabase}]{\setlength{\rightskip}{0pt plus 5cm}bool packetHandler::connectToDatabase ()}}
\label{classpacketHandler_a9366836a2e226a3193bea82dcbe80b5d}
Function to connect to database Also initializes the database. \begin{DoxyReturn}{Returns}
true if successful 
\end{DoxyReturn}


Definition at line 181 of file packethandler.cpp.




\begin{DoxyCode}
182 {
183         db = QSqlDatabase::addDatabase("QSQLITE");
184         db.setDatabaseName(":memory:");
185         if (!db.open()) {
186             QMessageBox::critical(0, tr("Cannot open database"),
187                 tr("Unable to establish a database connection.\n"
188                          "This example needs SQLite support. Please read "
189                          "the Qt SQL driver documentation for information how "
190                          "to build it.\n\n"
191                          "Click Cancel to exit."), QMessageBox::Cancel);
192             return false;
193         }
194 
195         QSqlQuery query;
196 
197         if(!query.exec("create table if not exists readings (id int, "
198                    "seq int, mgx int, mgy int, accx int, accy int, vl int, ir int
      , mic int, timeStamp date)"))
199             QMessageBox::critical(0, tr("Cannot execute query"),
200                 tr("Unable to execute query.\n"
201                          "Click Cancel to exit."), QMessageBox::Cancel);
202     return true;
203 }
\end{DoxyCode}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=200pt]{classpacketHandler_a9366836a2e226a3193bea82dcbe80b5d_icgraph}
\end{center}
\end{figure}


\hypertarget{classpacketHandler_a9085a61a51eccc7acb240a7b68601686}{
\index{packetHandler@{packetHandler}!dataReady@{dataReady}}
\index{dataReady@{dataReady}!packetHandler@{packetHandler}}
\subsubsection[{dataReady}]{\setlength{\rightskip}{0pt plus 5cm}void packetHandler::dataReady ()\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classpacketHandler_a9085a61a51eccc7acb240a7b68601686}


Slot for when there is new data ready from the serial forwarder. 



{\itshape Check\/} to see if the mote is already in the list, but mote id's must be sequential.

\begin{DoxyRemark}{Remarks}
Up to MAX\_\-BUFFER packets are stored in a ringBuffer for each mote. 
\end{DoxyRemark}




Definition at line 81 of file packethandler.cpp.




\begin{DoxyCode}
82 {
83     QByteArray bytes = source->readAll();
84 // Uncomment this to view the data
85     for(int j = 0; j < bytes.length(); j++)
86         printf("%02x   ", ((uint8_t) bytes[j]));
87     printf("\n");
88 
89     fflush(stdout);
90 
91     count++;
92 
93     if((int) bytes[0] != 0x1c)
94         return;
95 //      printf("Length = %d ", bytes.length());
96       int id = (int) (uint8_t) bytes[5];
97     //  qDebug() << "Count = " << motes.count() << "ID = " << id;
99       if(motes.count() <= id)
100       {
101           qDebug() << "Adding node " << id;
102           QList<MoteReading> temp;
103           ringBuffer.push_back(temp);
104           ringIndex.push_back(0);
105           motes.push_back(id);
106           emit this->nodesChanged();
107       }
108 // This doesnt work:
109 //      vl = ((uint8_t) bytes[14] & 0xf)*256  + ((uint8_t) (bytes[15]));
110 //      mic = ((uint8_t) bytes[16] & 0xf)*256 + ((uint8_t) (bytes[17]));
111 //      ir = ((uint8_t) bytes[18] & 0xf)*256 + ((uint8_t) (bytes[19]));
112 //      temp = ((uint8_t) bytes[19] & 0xf)*256 + ((uint8_t) (bytes[20]));
113 //      accx = ((uint8_t) bytes[21] & 0xf)*256  + ((uint8_t) (bytes[22]));
114 //      accy = ((uint8_t) bytes[23] & 0xf)*256 + ((uint8_t) (bytes[24]));
115 //      mgx = ((uint8_t) bytes[25] & 0xf) * 256 + ((uint8_t) (bytes[26]));
116 //      mgy = ((uint8_t) (bytes[27] & 0xf)) * 256 + ((uint8_t) (bytes[28]));
117 
118 
119       mgx = ((uint16_t) bytes[25]);
120       mgx = mgx << 8;
121       mgx ^= ((uint16_t) (bytes[26] & 0xff));
122 
123 
124       mgy = ((uint16_t) bytes[27]);
125       mgy = mgy << 8;
126       mgy ^= ((uint16_t) (bytes[28] & 0xff));
127 
128       accy = ((uint16_t) bytes[23]);
129       accy = accy << 8;
130       accy ^= ((uint16_t) (bytes[24] & 0xff));
131 
132       accx = ((uint16_t) bytes[21]);
133       accx = accx << 8;
134       accx ^= ((uint16_t) (bytes[22] & 0xff));
135 
136       temp = ((uint16_t) bytes[19]);
137       temp = temp << 8;
138       temp ^= ((uint16_t) (bytes[20] & 0xff));
139 
140       ir = ((uint16_t) bytes[17]);
141       ir = ir << 8;
142       ir ^= ((uint16_t) (bytes[18] & 0xff));
143 
144       vl = ((uint16_t) bytes[15]);
145       vl = vl << 8;
146       vl ^= ((uint16_t) (bytes[16] & 0xff));
147 
148       mic = ((uint16_t) bytes[13]);
149       mic = mic << 8;
150       mic ^= ((uint16_t) (bytes[14] & 0xff));
151 
152       seq = ((uint16_t) bytes[12]);
153 
154       MoteReading *tempReading = new MoteReading(id, mgx, mgy, accx, accy, temp, 
      ir, mic, vl, seq);
155 
157       // Added the first case for input validation
158       if(id < ringBuffer.count() && ringBuffer[id].count() < MAX_BUFFER)
159       {
160         ringBuffer[id].push_back(*tempReading);
161       }
162       else
163       {
164         if(ringIndex.count()-1 >= id && ringIndex[id] == MAX_BUFFER)
165           {
166               ringIndex[id] = 0;
167           }
168 
169           ringBuffer[id].replace(ringIndex[id], *tempReading);
170           ringIndex[id] = ringIndex[id] + 1;
171       }
172 
173 //      printf("%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n\n\n",tempReading->getVl(), tempR
      eading->getMic(),tempReading->getIr(),tempReading->getTemp(),tempReading->getAccx
      (),tempReading->getAccy(),tempReading->getMgx(),tempReading->getMgy());
174       //fflush(stdout);
175         QSqlQuery query;
176         if(!query.exec(QString("insert into readings values(%1, %2, %3, %4, %5, %
      6, %7, %8, %9, 0)").arg(id).arg(seq).arg(mgx).arg(mgy).arg(accx).arg(accy).arg(vl
      ).arg(ir).arg(mic)))
177             qDebug() << query.lastError();
178 
179 }
\end{DoxyCode}




Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=181pt]{classpacketHandler_a9085a61a51eccc7acb240a7b68601686_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=180pt]{classpacketHandler_a9085a61a51eccc7acb240a7b68601686_icgraph}
\end{center}
\end{figure}


\hypertarget{classpacketHandler_a43223a8930a6af8c40c5889d8e4b9d4b}{
\index{packetHandler@{packetHandler}!disconnected@{disconnected}}
\index{disconnected@{disconnected}!packetHandler@{packetHandler}}
\subsubsection[{disconnected}]{\setlength{\rightskip}{0pt plus 5cm}void packetHandler::disconnected ()\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classpacketHandler_a43223a8930a6af8c40c5889d8e4b9d4b}


Slot for when we are disconnected from the serial forwarder. 

\begin{DoxyRemark}{Remarks}
This gets called when the TcpSocket is disconnected, so we tell the dataGraph class also. 
\end{DoxyRemark}


Definition at line 53 of file packethandler.cpp.




\begin{DoxyCode}
54 {
55     emit disconnectNotice();
56 }
\end{DoxyCode}




Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=191pt]{classpacketHandler_a43223a8930a6af8c40c5889d8e4b9d4b_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=185pt]{classpacketHandler_a43223a8930a6af8c40c5889d8e4b9d4b_icgraph}
\end{center}
\end{figure}


\hypertarget{classpacketHandler_a7d07166d577b014234ad311599ac3291}{
\index{packetHandler@{packetHandler}!getNodeList@{getNodeList}}
\index{getNodeList@{getNodeList}!packetHandler@{packetHandler}}
\subsubsection[{getNodeList}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ int $>$ packetHandler::getNodeList ()}}
\label{classpacketHandler_a7d07166d577b014234ad311599ac3291}
Function to return the list of nodes from which we have received packets. \begin{DoxyReturn}{Returns}
QList$<$int$>$ 
\end{DoxyReturn}


Definition at line 74 of file packethandler.cpp.




\begin{DoxyCode}
75 {
76 
77     QList<int> list = QList<int>(motes);
78     return list;
79 }
\end{DoxyCode}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=258pt]{classpacketHandler_a7d07166d577b014234ad311599ac3291_icgraph}
\end{center}
\end{figure}


\hypertarget{classpacketHandler_aec6fa94602daa18227491b76001152cb}{
\index{packetHandler@{packetHandler}!getReading@{getReading}}
\index{getReading@{getReading}!packetHandler@{packetHandler}}
\subsubsection[{getReading}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MoteReading} packetHandler::getReading (int {\em i})}}
\label{classpacketHandler_aec6fa94602daa18227491b76001152cb}
Function to get the most recent reading for node i 
\begin{DoxyParams}{Parameters}
\item[{\em i}]The id of the mote. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classMoteReading}{MoteReading} 
\end{DoxyReturn}


\begin{Desc}
\item[\hyperlink{bug__bug000001}{Bug}]I need to get this working correctly, but I'm not sure on the logic yet. \end{Desc}




Definition at line 58 of file packethandler.cpp.




\begin{DoxyCode}
59 {
60         if(ringBuffer.count() > 0 && ringBuffer[i].count() < 0)
61     {
62         MoteReading *r = new MoteReading(0,0,0,0,0,0,0,0,0,0);
63         return *r;
64     }
65     else
66     {
68         MoteReading r = ringBuffer[i][0];
69     return r;
70     }
71 }
\end{DoxyCode}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=160pt]{classpacketHandler_aec6fa94602daa18227491b76001152cb_icgraph}
\end{center}
\end{figure}




The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
\hyperlink{packethandler_8h}{packethandler.h}\item 
\hyperlink{packethandler_8cpp}{packethandler.cpp}\end{DoxyCompactItemize}
